from __future__ import (division, absolute_import, print_function,
                        unicode_literals)

import bisect
import datetime
import hashlib
import io
import logging

import flask
import icalendar
import pytz

from flask import json

from schdl import app
from schdl import mongo
from schdl import users
from schdl import util


LOGGER = logging.getLogger(__name__)
DAYS = 'm', 'tu', 'w', 'th', 'f', 'sa', 'su'
RDAYS = reversed(DAYS)
DAY_NUMS = {
    'm': 0,
    'tu': 1,
    'w': 2,
    'th': 3,
    'f': 4,
    'sa': 5,
    'su': 6,
}
ICAL_DAYS = {
    'm': 'MO',
    'tu': 'TU',
    'w': 'WE',
    'th': 'TH',
    'f': 'FR',
    'sa': 'SA',
    'su': 'SU',
}

routes = util.RouteSet()


@routes.add('/api/ical/<school>/<secret>', methods=['GET'])
def ical(school, secret):
    school = app.mongo.db.schools.find_one_or_404(
        {'fragment': school},
        {'_id': False})
    c = mongo.SchoolCollections(school['fragment'])
    user = util.User(c.user.find_one_or_404({'secret': secret}), school)
    users.addInstructorCourses(c, user)
    schedules = user.formatSchedules(timestamps=True)
    cal = icalendar.Calendar()
    cal.add('prodid', '-//schdl/schdl//NONSGML v2.0//EN')
    cal.add('version', '2.0')
    # TODO(eitan): get timezone from school
    tz = pytz.timezone('America/New_York')
    cal.add('x-wr-calname;value=text', 'Schdl: %s' % user.name())
    cal.add('x-wr-timezone', 'America/New_York')
    # TODO(eitan): include link to this schedule
    cal.add('x-wr-caldesc', 'Generated by Schdl')
    cal.add_component(icalTimezone(tz, schedules))
    oneday = datetime.timedelta(days=1)
    for sch in schedules:
        term = sch['term']
        start = parseDate(term['start']).replace(tzinfo=tz)
        end = parseDate(term['end']).replace(tzinfo=tz) + oneday
        for sect in sch['course_sections']:
            if sect['user_status'] not in ('instructor', 'official'):
                continue
            for time in sect['times']:
                sha1 = hashlib.sha1()
                sha1.update(json.dumps(dict(
                    school=school['fragment'],
                    user=str(user['_id']),
                    start=start,
                    end=end,
                    sect=sect,
                    time=time)))
                uid = '%s@%s' % (sha1.hexdigest(), flask.request.host)
                cal.add_component(makeEvent(start, end, sect, time, uid))
    filename = '%s - %s.ics' % (user.school['name'], user.name())
    response = flask.Response(
        response=cal.to_ical(),
        mimetype=b'text/calendar',
    )
    response.headers.add(b'Content-Description', b'File Transfer')
    response.headers.add(b'Content-Disposition', b'attachment',
                         filename=filename.encode('utf-8'))
    return response


def makeEvent(term_start, term_end, section, meeting_time, uid):
    event = icalendar.Event()
    event.add('uid', uid)
    event.add('summary',
              '%s %s' % (section['course_code'], section['section']))
    first_day = firstOccurrence(term_start, meeting_time['days'])
    event.add('dtstart', replaceTime(first_day, meeting_time['start']))
    event.add('dtend', replaceTime(first_day, meeting_time['end']))
    event.add('dtstamp', section['user_updated'])
    event.add('categories', 'CLASS')
    rrule = icalendar.vRecur(
        freq='weekly',
        byday=icalDaysOfWeek(meeting_time['days']),
        until=term_end,
    )
    event.add('rrule', rrule)
    descr = io.StringIO()
    descr.write(section['course_name'])
    if 'type' in meeting_time:
        descr.write('\n' + meeting_time['type'])
    if section['instructors']:
        descr.write('\n\nInstructor')
        if len(section['instructors']) > 1:
            descr.write('s')
        descr.write(': ')
        descr.write(', '.join(util.name(instr)
                              for instr in section['instructors']))
    event.add('description', descr.getvalue())
    if meeting_time.get('building') or meeting_time.get('room'):
        loc = '%s %s' % (meeting_time.get('building', ''),
                         meeting_time.get('room', ''))
        event.add('location', loc.strip())
    return event


def parseDate(date):
    return datetime.datetime.strptime(date, '%Y-%m-%d')


def replaceTime(date, time):
    hour = time // 60
    minute = time % 60
    return date.replace(hour=hour, minute=minute)


def firstOccurrence(term_start, days):
    term_start_day = term_start.weekday()
    min_diff = 7
    for day in days:
        class_start_day = DAY_NUMS[day]
        diff = class_start_day - term_start_day
        if diff < 0:
            diff += 7
        if diff < min_diff:
            min_diff = diff
    assert min_diff < 7
    return term_start + datetime.timedelta(days=min_diff)


def icalDaysOfWeek(days):
    return [ICAL_DAYS[day] for day in days]


def icalTimezone(tz, schedules):
    ical_tz = icalendar.Timezone()
    ical_tz.add('tzid', tz.zone)
    transition_times = tz._utc_transition_times
    start = min(schedules,
                key=lambda sch: sch['term']['start'])['term']['start']
    start = parseDate(start)
    end = max(schedules, key=lambda sch: sch['term']['end'])['term']['end']
    end = parseDate(end)
    start_idx = bisect.bisect_left(transition_times, start)
    assert start_idx > 0
    from_offset = tz.utcoffset(transition_times[start_idx - 1])
    for time in transition_times[start_idx:]:
        offset = tz.utcoffset(time)
        tzname = tz.tzname(time)
        dst = tz.dst(time)
        time += from_offset
        if dst.total_seconds() == 0:
            transition = icalendar.TimezoneStandard()
        else:
            transition = icalendar.TimezoneDaylight()
        transition.add('tzname', tzname)
        transition.add('tzoffsetfrom', from_offset)
        transition.add('tzoffsetto', offset)
        transition.add('dtstart', time)
        ical_tz.add_component(transition)
        from_offset = offset
        if time > end:
            break
    return ical_tz
